# Yuroku（湯録）バックエンドアーキテクチャ

## 目次

1. [概要](#概要)
2. [クリーンアーキテクチャの原則](#クリーンアーキテクチャの原則)
3. [ディレクトリ構造](#ディレクトリ構造)
4. [レイヤー詳細](#レイヤー詳細)
   - [ドメイン層](#ドメイン層)
   - [ユースケース層](#ユースケース層)
   - [アダプター層](#アダプター層)
   - [インフラストラクチャ層](#インフラストラクチャ層)
5. [依存関係の流れ](#依存関係の流れ)
6. [データの流れ](#データの流れ)
7. [エラー処理](#エラー処理)
8. [テスト戦略](#テスト戦略)

## 概要

Yuroku（湯録）バックエンドは、クリーンアーキテクチャの原則に基づいて設計されています。このアーキテクチャは、ビジネスロジックをインフラストラクチャやフレームワークから分離し、テスト可能で保守性の高いコードベースを実現します。

本ドキュメントでは、バックエンドの構造、各レイヤーの役割、依存関係の流れ、およびデータの流れについて説明します。

## クリーンアーキテクチャの原則

クリーンアーキテクチャは以下の原則に基づいています：

1. **フレームワーク独立性**: ビジネスロジックはフレームワークに依存しない
2. **テスト可能性**: ビジネスルールはUIやデータベースなしでテスト可能
3. **UI独立性**: UIの変更がビジネスルールに影響しない
4. **データベース独立性**: データベースの変更がビジネスルールに影響しない
5. **外部エージェント独立性**: ビジネスルールは外部システムについて知らない

これらの原則を実現するために、アプリケーションは以下の4つの同心円レイヤーに分割されています：

1. **エンティティ**（最も内側）: ビジネスルールとデータ構造
2. **ユースケース**: アプリケーション固有のビジネスルール
3. **インターフェースアダプター**: 外部とのインターフェース
4. **フレームワークとドライバー**（最も外側）: 外部ツールやフレームワーク

依存関係は常に内側に向かって流れます。

## ディレクトリ構造

```
backend/
├── cmd/
│   └── api/
│       └── main.go       # エントリーポイント
├── internal/
│   ├── domain/           # ドメイン層（エンティティとビジネスルール）
│   │   ├── entity/       # ドメインエンティティ
│   │   ├── repository/   # リポジトリインターフェース
│   │   └── service/      # ドメインサービス
│   ├── usecase/          # ユースケース層（アプリケーションロジック）
│   │   ├── interactor/   # ユースケース実装
│   │   └── port/         # 入出力ポート
│   ├── adapter/          # アダプター層（インターフェースアダプター）
│   │   ├── controller/   # コントローラー
│   │   ├── gateway/      # リポジトリ実装
│   │   └── presenter/    # プレゼンター
│   └── infrastructure/   # インフラストラクチャ層（フレームワークとドライバー）
│       ├── database/     # データベース接続
│       ├── middleware/   # ミドルウェア
│       ├── router/       # ルーティング
│       └── storage/      # ストレージ
└── pkg/                  # 外部パッケージ
```

## レイヤー詳細

### ドメイン層

ドメイン層はアプリケーションの中心であり、ビジネスルールとエンティティを含みます。このレイヤーは他のどのレイヤーにも依存しません。

#### entity/

エンティティはビジネスオブジェクトとそのビジネスルールを表します。

- `user.go`: ユーザー情報を表すエンティティ
- `onsen_log.go`: 温泉メモを表すエンティティ
- `onsen_image.go`: 温泉画像を表すエンティティ

各エンティティは自身のバリデーションルールを持ち、ビジネスルールに従って動作します。

#### repository/

リポジトリはデータアクセスのための抽象インターフェースを定義します。具体的な実装はアダプター層で行われます。

- `user_repository.go`: ユーザーデータアクセスのインターフェース
- `onsen_log_repository.go`: 温泉メモデータアクセスのインターフェース
- `onsen_image_repository.go`: 温泉画像データアクセスのインターフェース
- `storage_repository.go`: ファイルストレージアクセスのインターフェース

#### service/

ドメインサービスはエンティティ間の操作や、単一のエンティティに属さないビジネスロジックを実装します。

- `auth_service.go`: 認証関連のビジネスロジック
- `onsen_log_service.go`: 温泉メモ関連のビジネスロジック
- `onsen_image_service.go`: 温泉画像関連のビジネスロジック

### ユースケース層

ユースケース層はアプリケーション固有のビジネスルールを実装します。このレイヤーはドメイン層に依存しますが、外部レイヤーには依存しません。

#### port/

ポートはユースケースの入出力インターフェースを定義します。

- `auth_port.go`: 認証ユースケースの入出力ポート
- `onsen_log_port.go`: 温泉メモユースケースの入出力ポート
- `onsen_image_port.go`: 温泉画像ユースケースの入出力ポート

各ポートファイルには、InputPort（ユースケースへの入力）とOutputPort（ユースケースからの出力）の両方が定義されています。

#### interactor/

インタラクターはユースケースの具体的な実装を提供します。

- `auth_interactor.go`: 認証ユースケースの実装
- `onsen_log_interactor.go`: 温泉メモユースケースの実装
- `onsen_image_interactor.go`: 温泉画像ユースケースの実装

インタラクターはドメインサービスを使用してビジネスロジックを実行し、結果をOutputPortを通じて外部に提供します。

### アダプター層

アダプター層は外部インターフェース（APIやデータベース）とユースケース層の間の変換を担当します。

#### controller/

コントローラーはHTTPリクエストを受け取り、ユースケースを呼び出します。

- `auth_controller.go`: 認証関連のAPIエンドポイント
- `onsen_log_controller.go`: 温泉メモ関連のAPIエンドポイント
- `onsen_image_controller.go`: 温泉画像関連のAPIエンドポイント

#### gateway/

ゲートウェイはリポジトリインターフェースの具体的な実装を提供します。

- `mongo_user_repository.go`: MongoDBを使用したユーザーリポジトリの実装
- `mongo_onsen_log_repository.go`: MongoDBを使用した温泉メモリポジトリの実装
- `mongo_onsen_image_repository.go`: MongoDBを使用した温泉画像リポジトリの実装
- `local_storage_repository.go`: ローカルファイルシステムを使用したストレージリポジトリの実装

#### presenter/

プレゼンターはユースケースの出力を適切な形式に変換します。

- `auth_presenter.go`: 認証ユースケースの出力を変換
- `onsen_log_presenter.go`: 温泉メモユースケースの出力を変換
- `onsen_image_presenter.go`: 温泉画像ユースケースの出力を変換

### インフラストラクチャ層

インフラストラクチャ層は外部ツール、フレームワーク、ドライバーとの統合を担当します。

#### database/

データベース接続を管理します。

- `mongodb.go`: MongoDB接続の設定と管理

#### middleware/

HTTPミドルウェアを提供します。

- `auth_middleware.go`: 認証ミドルウェア
- `cors_middleware.go`: CORS設定ミドルウェア
- `logging_middleware.go`: ロギングミドルウェア

#### router/

APIルーティングを設定します。

- `router.go`: Ginフレームワークを使用したルーティング設定

#### storage/

ファイルストレージを管理します。

- `local_storage.go`: ローカルファイルシステムストレージの実装
- `s3_storage.go`: AWS S3ストレージの実装

## 依存関係の流れ

依存関係は常に外側から内側に向かって流れます：

```
インフラストラクチャ層 → アダプター層 → ユースケース層 → ドメイン層
```

具体的には：

1. インフラストラクチャ層はアダプター層に依存します
2. アダプター層はユースケース層に依存します
3. ユースケース層はドメイン層に依存します
4. ドメイン層は他のどのレイヤーにも依存しません

この依存関係の方向性により、内側のレイヤー（特にドメイン層とユースケース層）は外側のレイヤーの変更から保護されます。

## データの流れ

典型的なリクエスト処理のデータフローは以下の通りです：

1. **HTTPリクエスト** → Router → Controller
2. Controller: リクエストデータを検証し、ユースケース入力データに変換
3. Controller → Interactor: ユースケース入力データを渡す
4. Interactor: ビジネスロジックを実行
   - 必要に応じてDomain Serviceを呼び出す
   - 必要に応じてRepositoryを通じてデータにアクセス
5. Interactor → Presenter: 出力データを渡す
6. Presenter: 出力データをHTTPレスポンス形式に変換
7. **HTTPレスポンス** ← Controller

## エラー処理

エラー処理は各レイヤーで適切に行われます：

1. **ドメイン層**: ドメインルールに関連するエラーを返します（例：無効な入力値）
2. **ユースケース層**: アプリケーションロジックに関連するエラーを返します
3. **アダプター層**: 外部システムとの統合に関連するエラーを変換します
4. **インフラストラクチャ層**: 技術的なエラーを適切に処理し、上位レイヤーに伝播します

エラーは常に意味のあるメッセージとエラーコードを持ち、クライアントに適切な情報を提供します。

## テスト戦略

クリーンアーキテクチャは各レイヤーを独立してテストすることを可能にします：

1. **ドメイン層テスト**: エンティティとドメインサービスの単体テスト
2. **ユースケース層テスト**: インタラクターの単体テスト（モックリポジトリを使用）
3. **アダプター層テスト**: コントローラー、ゲートウェイ、プレゼンターの単体テスト
4. **統合テスト**: 複数レイヤーを跨いだテスト
5. **E2Eテスト**: APIエンドポイントの動作検証

テストカバレッジの目標は70%以上とし、特にドメイン層とユースケース層は高いカバレッジを維持します。 